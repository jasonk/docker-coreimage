#!/bin/bash
### Remove cruft - mostly useful for removing excess stuff from images
## To see a list of available categories
##   docker-coreimage cleanup --list
## To cleanup a specific category of items:
##   docker-coreimage cleanup <category> [category...]
## To show what commands are run by a category:
##   docker-coreimage cleanup --commands <category> [category...]
## To show what files would be removed by a category:
##   docker-coreimage cleanup --show <category> [category...]
##
## You can also use the category 'ALL' to indicate nearly all the categories
## -- currently everything except 'service-configurations'.  If you want to
## cleanup all categories including 'service-configurations',
##   docker-coreimage cleanup ALL
## 
## If you really want to cleanup all categories, including
## 'service-configurations', then use 'REALLY_SERIOUSLY_ALL':
##   docker-coreimage cleanup REALLY_SERIOUSLY_ALL

set -e
shopt -s nullglob

CLEANERS="$(cd "$0.d">/dev/null && pwd)"

. "$(dirname "$0")/functions.sh"

function list-categories() {
    ls -1 "$CLEANERS"
}

function all-categories() {
    grep -vl '#!SCARY' "$CLEANERS"/* | awk -F/ '{print $NF}'
}

function scary-categories() {
    grep -l '#!SCARY' "$CLEANERS"/* | awk -F/ '{print $NF}'
}

function category-contents() {
    local CAT="$1"
    if [ -z "$CAT" ]; then return; fi
    cat "$CLEANERS/$CAT"
}

function categories() {
    echo "${CATEGORIES[@]}" | xargs -n1 | sort -u
}

CATEGORIES=()
COMMANDS=false
SHOW=false
LIST=false

if [ $# = 1 -a "$1" = "--list" ]; then list-categories ; exit ; fi

for ARG in "$@"; do
    case "$ARG" in
        --commands) COMMANDS=true   ; LIST=true ;;
        --list)     LIST=true                   ;;
        --files)    SHOW=true       ; LIST=true ;;
        --*) echo "Invalid argument: $ARG" 1>&2 ; exit 1 ;;
        ALL) CATEGORIES+=( $(all-categories) ) ;;
        REALLY_SERIOUSLY_ALL) CATEGORIES+=( $(list-categories) ) ;;
        *) CATEGORIES+=( "$ARG" ) ;;
    esac
done

function CMD_match() {
    for I in "$@"; do
        echo $I;
    done
}

function CMD_find() {
    find $@
}

function files() {
    local CAT="$1"

    sed -e 's/#.*//' "$CLEANERS/$CAT" | while read CMD ARGS; do
        if [ -z "$CMD" ]; then continue; fi
        CMD="CMD_$CMD"
        $CMD $ARGS
    done
}

for CAT in $( categories | sort -u); do
    INDENT=""
    if [ $LIST = true ]; then
        echo "$CAT"
        INDENT+="    "
    fi

    for FILE in $(files "$CAT"); do
        rm -f $FILE
    done
    echo
    #echo "$CLEANERS/$CAT"
done
